//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: 
//   Authors: Silvris
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------
/*
**************************************************
Massive thanks to "bnnm" on GitHub for his "wwiser" project, having effectively mapped out all versions of bnk. If you're looking at this file for reference, use that instead.
*/
local int i;
local int j;
local int k;
typedef struct{
    char dwTag[4];
    uint dwChunkSize;
}ChunkHeader;

//BKHD
typedef struct(uint chunkSize){
    uint dwBankGeneratorVersion; //should be 120 on a MHW nbnk
    uint dwSoundbankID; //fnv hash, normally of the file name
    uint dwLanguageID; //00 is SFX
    uint bFeedbackInBank;
    uint dwProjectID; // MHW = 1114
    for(i=0;i<((chunkSize/4)-5);i++){
        uint gap;
    };
}BankHeader;

//DIDX
typedef struct{
    uint pLoadedMedia;
    for(i=0;i<pLoadedMedia;i++){
        uint id;
        uint uOffset;
        uint uSize;
    };
}MediaIndex;

//DATA
typedef struct(uint dwChunkSize){
    byte pLoadedMedia[dwChunkSize];
}DataChunk;

//INIT
typedef struct{
    uint ulPluginID;
    uint uStringSize;
    string pDLLName;
}IAkPlugin;

typedef struct{
    uint pluginCount;
    for(i=0;i<pluginCount;i++){
        IAkPlugin Plugin;
    };
}PluginChunk;

//HIRC Common
typedef struct{
    byte eHircType;
    uint dwSectionSize;
    uint ulID;
}HircHeader;

typedef struct(uint length){
    byte datum[length];
}UnknData;

typedef struct{
    byte bIsOverrideParentFX;
    byte uNumFX;
    //worry about fixing this later
}NodeInitialFXParams;

typedef struct{
    byte cProps;
    for(i=0;i<cProps;i++){
        byte pID;
    };
    for(i=0;i<cProps;i++){
        uint pValue;
    };
}AkPropValue;

typedef struct{
    byte cProps;
    for(i=0;i<cProps;i++){
        byte pID;
        uint pValue;
    };
}AkPropRangedValue;

typedef struct{
    AkPropValue PropValues;
    AkPropRangedValue RangedPropValues;
}NodeInitialParams;

typedef struct{
    byte uBitsPositioning;
    local byte has_positioning = (uBitsPositioning >> 0 ) & 1;
    if(has_positioning)local byte has_3d = (uBitsPositioning >> 3) & 1;
    else local byte has_3d = 0;
    if(has_3d){
        byte uBits3D;
        uint attenuationID;
    };
}PositioningParams;

typedef struct{
    byte byBitVector;
    local byte has_aux = byBitVector >> 2;
    if(has_aux){
        uint auxID1;
        uint auxID2;
        uint auxID3;
        uint auxID4;
    };
}AuxParams;

typedef struct{
    byte byBitVector1;
    byte eVirtualQueueBehavior;
    uint16 uMaxNumInstance;
    byte eBelowThresholdBehavior;
    byte byBitVector2;
}AdvSettingsParams;

typedef struct{
    uint StateFrom;
    uint StateTo;
    uint TranisitonTime;
}StateTransition;

typedef struct{
    uint ulStateGroupID;
    uint DefaultTransitionTime;
    uint ulNumTransitions;
    for(i=0;i<ulNumTransitions;i++){
        StateTransition Transition;
    };
}StateGroup;

typedef struct{
    uint ulNumStateGroups;
    for(i=0;i<ulNumStateGroups;i++){
        uint ulStateGroupID;
        byte eStateSyncType;
        uint16 ulNumStates;
        for(j=0;j<ulNumStates;j++){
            uint ulStateID;
            uint ulStateInstanceID;
        };
    };
}StateChunk;

typedef struct{
    float To;
    float From;
    uint Interpolation;
}AkRTPCGraphPoint;

typedef struct{
    uint uClipIndex;
    uint eAutoType;
    uint uNumPoints;
    for(i=0;i<uNumPoints;i++){
        AkRTPCGraphPoint RTPCGraphPoint;
    };
}AkClipAutomation;

typedef struct{
    uint RTPCID;
    byte rtpcType;
    byte rtpcAccum;
    byte ParamID;
    uint rtpcCurveID;
    byte eScaling;
    uint16 ulSize;
    for(i=0;i<ulSize;i++){
        AkRTPCGraphPoint RTPCGraphPoint;
    };
}RTPC;

typedef struct{
    uint16 ulInitialRTPC;
    for(j=0;j<ulInitialRTPC;j++){
        RTPC rtpc;
    };
}InitialRTPC;

typedef struct{
    NodeInitialFXParams FXParams;
    byte bOverrideAttachmentParams;
    uint OverrideBusID;
    uint DirectParentID;
    byte byBitVector;//interpret further later
    NodeInitialParams IniParams;
    PositioningParams Positioning;
    AuxParams AuxParam;
    AdvSettingsParams AdvSettings;
    StateChunk States;
    InitialRTPC RTPCs;
}NodeBaseParams;

//Decision Tree Attempt
typedef struct{
    uint key;
    uint16 childIdx;
    uint16 childCount;
    uint16 uProbability;
    uint16 uWeight;
}UpperNode;

typedef struct{
    uint key;
    uint audioNodeID;
    uint16 uProbability;
    uint16 uWeight;
}LowerNode;
local int newChildCount = 0;
struct depth;
struct depth(uint maxDepth,uint CurrentDepth){
    newChildCount=0;
    if(CurrentDepth < maxDepth){
        UpperNode depthNode;
        for(j=0;j<depthNode.childCount;j++){
            depth nextDepth(maxDepth,CurrentDepth+1);
        };
    };
    if(CurrentDepth == maxDepth){
        LowerNode audioNode;
    };
};

struct DecisionTree(uint Depth){
    //first depth will always only be one, so we can immediately declare it
    UpperNode firstNode;
    UpperNode Depth1Node[firstNode.childCount];
    if(Depth > 1){
        for(j=0;j<firstNode.childCount;j++){
            for(i=0;i<Depth1Node.childCount;i++){
                depth firstDepth(Depth,1);
            };
        };
    };
};

//HIRC 1
typedef struct{
    byte cProps;
    for(i=0;i<cProps;i++){
        byte pID;
    };
    for(i=0;i<cProps;i++){
        float pValue;
    };
}State;
//HIRC 3
typedef struct{
    uint ulStateGroupID;
    uint ulTargetStateID;
}StateActionParams;

typedef struct{
    byte byBitVector;
    uint ulExceptionListSize;
    //there will be more here
}ActiveActionParams;

typedef struct{
    byte bBypassTransition;
    byte eValueMeaning;
    float base;
    float min;
    float max;
    uint ulExceptionListSize;
    //there will be more here
}GameParameterParams;

typedef struct{
    byte eValueMeaning;
    float base;
    float min;
    float max;
    uint ulExceptionListSize;
}PropActionParams;

typedef struct(uint16 ulActionType){
    byte byBitVector;
    if(ulActionType==0x1302)GameParameterParams SpecificParams;
    if(ulActionType==0x0A02)PropActionParams SpecificParams;
    if(ulActionType==0x0B02)PropActionParams SpecificParams;
    if(ulActionType==0x0C02)PropActionParams SpecificParams;
    if(ulActionType==0x0D02)PropActionParams SpecificParams;
}ValueActionParams;

typedef struct{
    byte eFadeCurve;
    uint fileID;
}PlayActionParams;

typedef struct{
    uint16 ulActionType;
    uint idExt;
    byte idExt_4;
    AkPropValue PropValues;
    AkPropRangedValue RangedPropValues;
    if(ulActionType == 0x1204)StateActionParams StateAction;
    if(ulActionType == 0x0102)ActiveActionParams ActiveAction;
    if(ulActionType == 0x0103)ActiveActionParams ActiveAction;
    if(ulActionType == 0x1302)ValueActionParams ValueAction(ulActionType);
    if(ulActionType == 0x0A02)ValueActionParams ValueAction(ulActionType);
    if(ulActionType == 0x0B02)ValueActionParams ValueAction(ulActionType);
    if(ulActionType == 0x0C02)ValueActionParams ValueAction(ulActionType);
    if(ulActionType == 0x0D02)ValueActionParams ValueAction(ulActionType);
    if(ulActionType == 0x0403)PlayActionParams PlayAction;
}Action;

//HIRC 4
typedef struct{
    uint ulActionListSize;
    for(i=0;i<ulActionListSize;i++){
        uint ulActionID;
    };
}Event;

//HIRC 8
typedef struct{
    AkPropValue PropValues;
    byte BitVector1;
    byte BitVector2;
    uint16 u16MaxNumInstance;
    uint uChannelConfig;
    byte BitVector3;
}BusInitialParams;

typedef struct{
    byte uFXIndex;
    uint fxID;
    byte bIsShareSet;
    byte bIsRendered;
}FXChunk;

typedef struct{
    byte uNumFX;
    if(uNumFX)byte bitsFXBypass;
    for(j=0;j<uNumFX;j++){
        FXChunk pFXChunk;
    };
    uint fxID_0;
    byte bIsShareSet_0;
}BusInitialFXParams;

typedef struct{
    uint BusID;
    float DuckVolume;
    int FadeOutTime;
    int FadeInTime;
    byte eFadeCurve;
    byte TargetProp;
}DuckInfo;

typedef struct{
    uint OverrideBusID;
    BusInitialParams InitialParams;
    int RecoveryTime;
    float fMaxDuckVolume;
    uint ulDucks;
    for(j=0;j<ulDucks;j++){
        DuckInfo Duck;
    };
    BusInitialFXParams FXParams;
    byte bOverrideAttachmentParams;
    InitialRTPC RTPCs;
    StateChunk States;
}AudioBus;

//HIRC 10
typedef struct{
    uint uNumChildren;
    for(i=0;i<uNumChildren;i++){
        uint ulChildID;
    };
}Children;

typedef struct{
    double fGridPeriod;
    double fGridOffset;
    float fTempo;
    byte uNumBeatsPerBar;//top number of time signature
    byte uBeatValue;//bottom number of time signature
}AkMeterInfo;

typedef struct{
    uint TriggerID;
    uint SegmentID;
    uint SyncPlayAt;
    uint uCueFilterHash;
    int DontRepeatTime;
    uint numSegmentLookAhead;
}AkStinger;

typedef struct{
    byte uFlags;
    NodeBaseParams BaseParams;
    Children ChildrenList;
    AkMeterInfo MeterInfo;
    byte bMeterInfoFlag;
    uint uNumStingers;
    for(i=0;i<uNumStingers;i++){
        AkStinger Stinger;
    };
}MusicNodeParams;

typedef struct{
    uint id;
    double fPosition;
    uint uStringSize;
    if(uStringSize > 0)string pMarkerName;
}MusicMarker;

typedef struct{
    MusicNodeParams MusicParams;
    double fDuration;
    uint ulNumMarkers;
    for(i=0;i<ulNumMarkers;i++){
        MusicMarker WWiseMarker;
    };
}MusicSegment;

//HIRC 11
typedef struct{
    uint ulPluginID;
    byte StreamType;
    uint sourceID;
    uint uInMemorySize;
    byte uSourceBits;
}pSource;

typedef struct{
    uint trackID;
    uint sourceID;
    double fPlayAt;
    double fBeginTrimOffset;
    double fEndTrimOffset;
    double fSrcDuration;
}pPlaylist;

typedef struct{
    byte eGroupType;
    uint uGroupID;
    uint uDefaultSwitch;
    uint numSwitchAssoc;
    for(i=0;i<numSwitchAssoc;i++){
        uint ulSwitchAssoc;
    };
}SwitchParams;

typedef struct{
    int transitionTime;
    uint eFadeCurve;
    int iFadeOffset;
}FadeParams;

typedef struct{
    FadeParams srcFadeParams;
    uint eSyncType;
    uint uCueHashFilter;
    FadeParams destFadeParams;
}TransParams;

typedef struct{
    byte uFlags;
    uint numSources; //this seems promising to play with
    for(i=0;i<numSources;i++){
        pSource Source;
    };
    uint numPlaylistItem;
    for(i=0;i<numPlaylistItem;i++){
        pPlaylist Playlist;
    };
    if(numPlaylistItem>0) uint numSubTrack;//doesn't seem to have children?
    uint numClipAutomationItem;
    for(j=0;j<numClipAutomationItem;j++){
        AkClipAutomation ClipAutomation;
    };
    NodeBaseParams BaseParams;
    byte eTrackType;
    if(eTrackType == 3){
        SwitchParams SwitchParam;
        TransParams TransParam;
    };
    int iLookAheadTime;
}MusicTrack;

//HIRC 12
typedef struct{
    FadeParams FadeParam;
    uint uCueFilterHash;
    uint uJumpToID;
    uint16 eEntryType;
    byte bPlayPreEntry;
    byte bDestMatchSourceCueName;
}AkMusicTransSrcRule;

typedef struct{
    FadeParams FadeParam;
    uint eSyncType;
    uint uCueFilterHash;
    byte bPlayPostExit;
}AkMusicTransDstRule;

typedef struct{
    uint segmentID;
    FadeParams fadeInParams;
    FadeParams fadeOutParams;
    byte PlayPreEntry;
    byte PlayPostExit;
}AkMusicTransitionObject;

typedef struct{
    uint uNumSrc;
    for(i=0;i<uNumSrc;i++){
        uint srcNumID;
    };
    uint uNumDst;
    for(i=0;i<uNumDst;i++){
        uint dstNumID;
    };
    AkMusicTransSrcRule SrcRule;
    AkMusicTransDstRule DstRule;
    byte AllocTransObjectFlag;
    if(AllocTransObjectFlag){
        AkMusicTransitionObject MusicTransition;
    };
}MusicTransitionRule;

typedef struct{
    MusicNodeParams MusicParams;
    uint numRules;
    for(j=0;j<numRules;j++){
        MusicTransitionRule Rule;
    };
}MusicTransNodeParams;

typedef struct{
    uint ulGroup;
    byte eGroupType;
}AkGameSync;

typedef struct{
    MusicTransNodeParams MusicTransParams;
    byte bIsContinuePlayback;
    uint uTreeDepth;
    for(i=0;i<uTreeDepth;i++){
        AkGameSync Arguments;
    };
    uint uTreeSize;
    byte bMode;
    byte decisionTree[uTreeSize];//it's a bit intricate, hard to do in 010 C
//    DecisionTree decisionTree(uTreeDepth);
}MusicSwitch;

//HIRC 13
struct pPlaylistItem;
struct pPlaylistItem{
    uint SegmentID;
    uint playlistItemID;
    uint NumChildren;
    uint eRSType;
    int16 Loop;
    int16 LoopMin;
    int16 LoopMax;
    uint Weight;
    uint16 wAvoidRepeatCount;
    byte bIsUsingWeight;
    byte bIsShuffle;
    //these technically have children, but NumPlaylistItems actually takes them into account
};

typedef struct{
    MusicTransNodeParams MusicTransParams;
    uint numPlaylistItems;
    for(i=0;i<numPlaylistItems;i++){
        pPlaylistItem playlistItem;
    };
}MusicPlaylist;

//HIRC 14
typedef struct{
    byte eScaling;
    uint16 ulSize;
    for(i=0;i<ulSize;i++){
        AkRTPCGraphPoint RTPCGraphPoint;
    };
}CAkConversionTable;

typedef struct{
    ubyte bIsConeEnabled;
    byte curveToUse[7];
    byte NumCurves;
    for(i=0;i<NumCurves;i++){
        CAkConversionTable Curve;
    };
    uint16 ulNumRTPC; //to-do there is a for here, but not present in bgm_ingame_cmn
}Attenuation;

//HIRC 18
typedef struct{
    uint fxID;//determined by type and company
    uint uSize;
    byte pParamBlock[uSize];//WWiser doesn't even try to read this, I suppose it's different for each fx
    byte uNumBankData;
    InitialRTPC RTPCs;
    uint16 ulNumInit;
    //inits go here
}FxShareSet;

//HIRC 20
typedef struct{
    //It's literally just an Audio Bus, but *technically* different
    uint OverrideBusID;
    BusInitialParams InitialParams;
    int RecoveryTime;
    float fMaxDuckVolume;
    uint ulDucks;
    for(j=0;j<ulDucks;j++){
        DuckInfo Duck;
    };
    BusInitialFXParams FXParams;
    byte bOverrideAttachmentParams;
    InitialRTPC RTPCs;
    StateChunk States;
}AuxiliaryBus;

//HIRC Main
typedef struct{
    HircHeader Header<bgcolor=0xFF00FF>;
    switch(Header.eHircType){
        case 1:
            State Object<name="State",bgcolor=0xFF0000>;//honestly a little closer to being settings
            break;
        case 3:
            Action Object<name="Action",bgcolor=0xCFB3FF>;
            break;
        case 4:
            Event Object<name="Event",bgcolor=0xD3FFB3>;
            break;
        case 8:
            AudioBus Object<name="Audio Bus",bgcolor=0xFFBAB3>;
            break;
        case 10:
            MusicSegment Object<name="Music Segment",bgcolor=0x33FFBD>;
            break;
        case 11:
            MusicTrack Object<name="Music Track",bgcolor=0xB3FFD0>;
            break;
        case 12:
            MusicSwitch Object<name="Music Switch",bgcolor=0xB3FFB3>;
            break;
        case 13:
            MusicPlaylist Object<name="Music Playlist",bgcolor=0xFF4040>;\
            break;
        case 14:
            Attenuation Object<name="Attenuation",bgcolor=0x40C2FF>;
            break;
        case 18:
            FxShareSet Object<name="FX Share Set",bgcolor=0x7440FF>;
            break;
        case 20:
            AuxiliaryBus Object<name="Auxiliary Bus",bgcolor=0x407AFF>;
            break;
        default:
            UnknData Object(Header.dwSectionSize-4)<name="Unknown Data",bgcolor=0x000000>;
            break;
    };
}HircObject;

typedef struct{
    uint NumReleasableHircItem;
    for(k=0;k<NumReleasableHircItem;k++){
        HircObject Object<name="Hirc Object">;
    };
}ObjectHierarchy;

//STMG
typedef struct{
    uint SwitchGroupID;
    uint RTPCID;
    byte RTPCType;
    uint ulSize;//actually a count;
    for(i=0;i<ulSize;i++){
        AkRTPCGraphPoint GraphPoint;
    };
}SwitchGroup;

typedef struct{
    uint RTPC_ID;
    float fValue;
    uint rampType;
    float fRampUp;
    float fRampDown;
    byte eBindToBuiltInParam;
}RTPCRamping;

typedef struct{
    float fVolumeThreshold;
    uint16 maxNumVoicesLimitInternal;
    uint ulNumStateGroups;
    for(j=0;j<ulNumStateGroups;j++){
        StateGroup StateGroups;
    };
    uint ulNumSwitchGroup;
    for(j=0;j<ulNumSwitchGroup;j++){
        SwitchGroup SwitchGroups;
    };
    uint ulNumParams;
    for(j=0;j<ulNumParams;j++){
        RTPCRamping RTPCRamp;
    };
    uint ulNumTextures;
    //we don't get to know what this does, unused by MHW
    uint ulNumReverberator;
    //same
}StateManager;
    
//ENVS
typedef struct{
    byte bCurveEnabled;
    byte eCurveScaling;
    uint16 ulCurveSize;
    for(i=0;i<ulCurveSize;i++){
        AkRTPCGraphPoint GraphPoint;
    };
}ObsOccCurve;

typedef struct{
    ObsOccCurve ObsVol;
    ObsOccCurve ObsLPF;
    ObsOccCurve ObsHPF;
    ObsOccCurve OccVol;
    ObsOccCurve OccLPF;
    ObsOccCurve OccHPF;
}EnvironmentSettings;

//PLAT
typedef struct{
    uint uStringSize;
    string pCustomPlatformName;
}CustomPlatform;

//File Main

struct FileBlock{
    ChunkHeader Header<bgcolor=0xFFFF00>;
    switch(Header.dwTag){
        case "BKHD":
            BankHeader BKHD(Header.dwChunkSize)<name="Bank Header",bgcolor=0x0000FF>;
            break;
        case "INIT":
            PluginChunk INIT<name="Plugins",bgcolor=0x567890>;
            break;
        case "DIDX":
            MediaIndex DIDX<name="Media Index",bgcolor=0xFF0000>;
            break;
        case "DATA":
            DataChunk DATA<name="Data Chunk",bgcolor=0x00FF00>;
            break;
        case "HIRC":
            ObjectHierarchy HIRC<name="Object Hierarchy",bgcolor=0x123456>;
            break;
        case "STMG":
            StateManager STMG<name="State Manager",bgcolor=0x987654>;
            break;
        case "ENVS":
            EnvironmentSettings ENVS<name="Environment Settings",bgcolor=0x489863>;
            break;
        case "PLAT":
            CustomPlatform PLAT<name="Custom Platform Name",bgcolor=0xF0F0F0>;
            break;
        default:
            UnknData Object(Header.dwChunkSize)<name="Unknown Data",bgcolor=0x000000>;
            break;
    };
};
while(FTell()<FileSize()){
    FileBlock Block;
};